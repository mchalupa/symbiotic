#!/usr/bin/env python3

from os.path import basename
from hashlib import sha256 as hashfunc
import subprocess
import datetime
import re
import yaml
import uuid
from ..options import get_versions

def get_hash(source):
    f = open(source, 'r', encoding='utf-8')
    hsh = hashfunc()
    for l in f:
        hsh.update(l.encode('utf-8'))

    f.close()
    return hsh.hexdigest()

class YAMLWriter(object):
    def __init__(self, source, prps, is32bit, is_correctness_wit):
        self._source = source
        self._prps = prps
        self._is32bit = is32bit
        self._correctness_wit = is_correctness_wit

        self.test = []
        self.errorLoc = None
        self.witness = []

    def add_metadata(self):
        witness = {}
        witness['entry_type'] = "violation_sequence" if not self._correctness_wit else "correctness_witness"
        witness['metadata'] = {
            'format_version' : "2.0",
            'creation_time' :  '{date:%Y-%m-%dT%T}Z'.format(date=datetime.datetime.utcnow()),
            'producer' : {'name' : 'symbiotic',
                          'version' : get_versions()[0] },
            'uuid' : str(uuid.uuid4()),
            'task' :
                { 'input_files' : [self._source],
                  'input_file_hashes' : { self._source : get_hash(self._source)},
                  
                  # It would probably be better to only output the one violated (sub)property instead of all the
                  # checked (sub)properties. However, it's not specified in the format yet so I'm keeping it as 
                  # it was in the GraphML witnesses. 
                  'specification' : ','.join(self._prps), 
                  'data_model' : "ILP32" if self._is32bit else "LP64",
                  'language' : "C"}
        }
        self.witness.append(witness)


    def generate_witness(self, path, is_termination):
        """
        Take a .graphml file generated by a tool and generate a new
        .graphml file from it that has all the needed metadata.

        \param path         the .waypoints file
        """
        # parse the graphml file from KLEE
        self.parse(path)
        assert self.errorLoc, "Failed parsing a witness" + path 

        self.add_metadata()
        self.create_content()


    def generate_violation_witness(self, path, is_termination):
        self.generate_witness(path, is_termination)

    def dump(self):
        print(self.witness)

    def write(self, to):
        with open(to, "w") as witness_file:
            yaml.safe_dump(self.witness, witness_file, default_style=None)
 
    def get_locations(self):
        this_file = True
        shifterror = True
        call_map = dict()
        last_ln = "" 
        ast = subprocess.run(['clang', '-Xclang', '-ast-dump', '-fsyntax-only', '-fno-color-diagnostics', self._source], 
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.DEVNULL).stdout.decode('utf-8')
        
        for line in ast.splitlines():
            # check if we have a begin and end
            loc = re.search("^[^-]*-[a-zA-Z]* 0x[0-9A-Fa-f]* <([^>,]*), ([^,]*)>", line)

            if not loc:  # if not, we only care about the line
                ln = re.search("^[^-]*-[a-zA-Z]* 0x[0-9A-Fa-f]* <([^:>]*):([0-9]*)", line)
                if ln and ln[1] != "col":
                    last_ln = ln[2]
                    if ln[1] != "line":
                        this_file = ln[1] == self._source
                continue

            start = loc[1]
            end = loc[2]

            location = re.search("([^:]*):([0-9]*):([0-9]*)", start)
            if not location:
                if not this_file:
                    continue
                # if there's no line specified, use the previous one
                name = None
                start_ln = last_ln
                start_col = re.search("col:([0-9]*)", start)[1]
                if not start_col:
                    continue
            else:
                name = location[1]
                start_ln = location[2]
                start_col = location[3]

            # if there is a filename, check if its the program under validation - we do not care about headers
            if name and name != "line":
                if name != self._source:
                    this_file = False
                    continue
                else:
                    this_file = True

            # update last line
            last_ln = start_ln

            # again, check if there's a line number, otherwise use previous
            if "line" in end:
                end_loc = re.search("line:([0-9]*):([0-9]*)", end)
                end_ln, end_col = end_loc[1], end_loc[2]
            else:
                end_ln = last_ln
                end_col_match = re.search("col:([0-9]*)", end)
                if not end_col_match:
                    this_file = False
                    continue
                end_col = end_col_match[1]

            last_ln = end_ln

            if not this_file:
                continue

            start_location = start_ln + ":" + start_col
            end_location = end_ln + ":" + end_col

            # index callmap by start location
            if "CallExpr" in line:
                if start_location not in call_map:
                    call_map[start_location] = end_location

            if not shifterror or "FunctionDecl" in line \
                or "CompoundStmt" in line \
                or "IfStmt" in line \
                or "DoStmt" in line \
                or "WhileStmt" in line \
                or "ForStmt" in line \
                or "LabelStmt" in line \
                or "DeclStmt" in line \
                or "VarDecl" in line:
                continue
            
    
            if int(start_ln) > int(self.errorLoc[1]) or int(end_ln) < int(self.errorLoc[1]):
                continue

            if (int(start_ln) == int(self.errorLoc[1]) and int(start_col) > int(self.errorLoc[2])) or \
                (int(end_ln) == int(self.errorLoc[1]) and int(end_col) < int(self.errorLoc[2])):
                continue

            # For memtrack
            #if "ReturnStmt" in line and (int(start_ln) != int(self.errorLoc[1]) or \
            #                                              int(start_col) != int(self.errorLoc[2])):
                continue      

            self.errorLoc[1] = int(start_ln)
            self.errorLoc[2] = int(start_col)
            shifterror = False

        if shifterror:
            print("Something went wrong. Error location might not comply with the witness format.")
            self.errorLoc[1] = int(self.errorLoc[1])
            self.errorLoc[2] = int(self.errorLoc[2])

        return call_map

    def create_content(self):
        content = []

        call_map = self.get_locations()

        for call in self.test:
            loc = "{line}:{col}".format(line=call[1], col=call[2])
            assert loc in call_map, "Failed creating witness"
            call[1], call[2] = map(int, call_map[loc].split(':'))
            segment = []
            waypoint = { 'type' : 'function_return',
                          'action' : 'follow',
                          'constraint' : {
                            'format' : 'c_expression',
                            'value' : '\\result == ' + call[3]
                          },
                          'location' : {
                            'file_name' : self._source,
                            'file_hash' : get_hash(self._source),
                            'line' : call[1],
                            'column' : call[2]
                          }

                        }
            segment.append({'waypoint' : waypoint})
            content.append({'segment' : segment})

        target_segment = []
        target = { 'type' : 'target',
                   'action' : 'follow',
                   'location' : {
                            'file_name' : self.errorLoc[0],
                            'file_hash' : get_hash(self._source),
                            'line' : self.errorLoc[1],
                            'column' : self.errorLoc[2]
                          }

                 }
            
        target_segment.append({'waypoint' : target})
        content.append({'segment' : target_segment})

        self.witness[0]['content'] = content



    def parse(self, path):
        with open(path, "r") as testfile:
            for line in testfile.readlines():
                if line[0] == '@':
                    self.errorLoc = line.strip('\n').split(':')[1:]
                    break
                self.test.append(line.strip('\n').split(':'))

